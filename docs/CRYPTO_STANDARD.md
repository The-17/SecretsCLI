# Cryptography Standard for SecretsCLI Implementations

This document defines the cryptographic requirements for any CLI implementation that wants to interoperate with SecretsCLI and the SecretsAPI.

> **Why This Matters:** When Alice (Python CLI) invites Bob (Go CLI) to a workspace, Alice encrypts the workspace key using Bob's public key. Bob's CLI must be able to decrypt it. Both must use the same algorithm.

---

## Required Algorithms

### Asymmetric Encryption (Key Wrapping)

Used for: Encrypting workspace keys for other users.

| Property | Value |
|----------|-------|
| **Algorithm** | X25519 + XSalsa20-Poly1305 (NaCl SealedBox) |
| **Library** | Any NaCl/LibSodium implementation |
| **Key Format** | Raw 32-byte keys, base64-encoded for transport |

**Language Libraries:**

| Language | Library | Install |
|----------|---------|---------|
| Python | PyNaCl | `pip install pynacl` |
| Go | `golang.org/x/crypto/nacl/box` | Standard |
| Rust | `sodiumoxide` or `crypto_box` | `cargo add sodiumoxide` |
| JavaScript | `tweetnacl` | `npm install tweetnacl` |
| Java | `lazysodium-java` | Maven |

### Symmetric Encryption (Secrets)

Used for: Encrypting secret values with workspace key.

| Property | Value |
|----------|-------|
| **Algorithm** | Fernet (AES-128-CBC + HMAC-SHA256) OR AES-256-GCM |
| **Key Size** | 32 bytes |
| **Key Format** | Raw bytes, base64-encoded for transport |

> **Note:** The symmetric algorithm is flexible since only the same user decrypts their own secrets. Fernet is recommended for simplicity.

### Key Derivation (Password → User Key)

Used for: Deriving encryption key from user's password.

| Property | Value |
|----------|-------|
| **Algorithm** | PBKDF2-HMAC-SHA256 |
| **Iterations** | 100,000 minimum |
| **Salt** | 16 bytes, random, stored with user |
| **Output** | 32 bytes |

---

## Key Types and Storage

| Key | Generated By | Stored At | Encrypted With |
|-----|--------------|-----------|----------------|
| **User Key** | CLI (from password) | Never stored | — |
| **Private Key** | CLI (at registration) | API | User Key (Fernet) |
| **Public Key** | CLI (at registration) | API | Plaintext (it's public) |
| **Workspace Key** | CLI (at workspace creation) | API (per-member) | Recipient's Public Key |

---

## Wire Formats

### Registration Request

```json
{
  "email": "user@example.com",
  "password": "...",
  "first_name": "John",
  "public_key": "<base64: 32-byte X25519 public key>",
  "encrypted_private_key": "<base64: Fernet-encrypted 32-byte private key>",
  "key_salt": "<base64: 16-byte PBKDF2 salt>"
}
```

### Login Response

```json
{
  "access": "jwt...",
  "refresh": "jwt...",
  "expires_at": "2024-01-15T22:30:00Z",
  "key_salt": "<base64>",
  "encrypted_private_key": "<base64>",
  "workspaces": [
    {
      "id": "uuid",
      "name": "My Workspace",
      "encrypted_workspace_key": "<base64: NaCl SealedBox encrypted>"
    }
  ]
}
```

### Workspace Invite Request

```json
{
  "email": "invitee@example.com",
  "role": "member",
  "encrypted_workspace_key": "<base64: workspace_key encrypted with invitee's public key>"
}
```

---

## Implementation Examples

### Python (PyNaCl)

```python
from nacl.public import PrivateKey, PublicKey, SealedBox
from nacl.encoding import Base64Encoder

# Generate keypair
private_key = PrivateKey.generate()
public_key = private_key.public_key

# Export for API
public_key_b64 = public_key.encode(Base64Encoder).decode()
private_key_bytes = bytes(private_key)  # Encrypt this with Fernet before sending

# Encrypt workspace key for another user
recipient_public = PublicKey(base64.b64decode(their_public_key_b64))
sealed_box = SealedBox(recipient_public)
encrypted = sealed_box.encrypt(workspace_key)
encrypted_b64 = base64.b64encode(encrypted).decode()

# Decrypt workspace key received from another user
my_sealed_box = SealedBox(my_private_key)
workspace_key = my_sealed_box.decrypt(base64.b64decode(encrypted_b64))
```

### Go

```go
import (
    "golang.org/x/crypto/nacl/box"
    "crypto/rand"
)

// Generate keypair
publicKey, privateKey, _ := box.GenerateKey(rand.Reader)

// Encrypt for recipient (using box.Seal with ephemeral key for SealedBox equivalent)
// See: https://pkg.go.dev/golang.org/x/crypto/nacl/box#example-package-SealAnonymous
```

---

## Security Notes

1. **Never log or print private keys or workspace keys**
2. **Store private key in OS keychain** when possible (macOS Keychain, Windows Credential Manager)
3. **Server never sees plaintext workspace keys** - only encrypted blobs
4. **Password changes only re-encrypt private_key** - workspace keys unchanged

---

## Testing Interoperability

To verify your implementation works with others:

1. Generate a keypair
2. Export public key as base64
3. Have another implementation encrypt test data to your public key
4. Verify you can decrypt it

Test vectors will be provided in `tests/crypto_vectors.json`.
